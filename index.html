<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Image / GIF / Video → Live ASCII (Sliding Window)</title>
<style>
  :root { --bg:#0b0b0b; --fg:#eaeaea; --muted:#888; --accent:#4aa3ff; }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:monospace}
  .wrap{padding:18px;max-width:1200px;margin:0 auto}
  label,input,button{margin:6px}
  #asciiOutput{white-space:pre; display:inline-block; text-align:left; line-height:7px; font-size:8px; vertical-align:top; max-height:80vh; overflow:auto;}
  .controls{margin:12px 0}
  progress{width:380px;height:14px;vertical-align:middle}
  .small{font-size:12px;color:var(--muted)}
  button[disabled]{opacity:0.5}
  .rightcol{display:inline-block; vertical-align:top; margin-left:20px}
</style>
</head>
<body>
  <div class="wrap">
    <h2>Image / GIF / Video → ASCII (Sliding Window)</h2>

    <div class="controls">
      <input id="mediaInput" type="file" accept="image/*,video/*" />
      <label>Width (chars)</label>
      <input id="size" type="number" value="120" min="10" max="800" />
      <label><input id="color" type="checkbox" /> Color</label>
      <button id="convertBtn" type="button">Convert</button>

      <div style="margin-top:8px">
        <label>Capture FPS (video) </label>
        <input id="captureFps" type="number" value="15" min="1" max="60" style="width:70px" />
        <label style="margin-left:10px">Max Frames</label>
        <input id="maxFrames" type="number" value="2000" min="10" max="5000" style="width:80px" />
      </div>

      <div style="margin-top:8px">
        <button id="pauseBtn" type="button" disabled>Pause</button>
        <button id="resumeBtn" type="button" disabled>Resume</button>
        <label style="margin-left:8px">Speed (ms/frame)</label>
        <input id="speed" type="number" value="100" min="10" max="2000" style="width:80px" />
      </div>

      <div style="margin-top:10px">
        <progress id="progress" value="0" max="100"></progress>
        <span id="progressText">Idle</span>
      </div>
    </div>

    <div>
      <pre id="asciiOutput"></pre>
      <div class="rightcol small">
        <div id="info">Ready.</div>
        <div id="notes" style="margin-top:8px;color:var(--muted)">
          Notes: videos use seeking to capture frames (accurate). GIF capture uses a heuristic (captures until it detects the first frame again or max frames). Only a sliding window of frames is kept to save memory.
        </div>
      </div>
    </div>
  </div>

<script>
const asciiChars = " .:-=+*#%@";
const mediaInput = document.getElementById('mediaInput');
const convertBtn  = document.getElementById('convertBtn');
const asciiOutput  = document.getElementById('asciiOutput');
const sizeInput = document.getElementById('size');
const colorCheckbox = document.getElementById('color');
const captureFpsInput = document.getElementById('captureFps');
const maxFramesInput = document.getElementById('maxFrames');
const progressEl = document.getElementById('progress');
const progressText = document.getElementById('progressText');
const infoEl = document.getElementById('info');
const pauseBtn = document.getElementById('pauseBtn');
const resumeBtn = document.getElementById('resumeBtn');
const speedInput = document.getElementById('speed');

let frames = []; // sliding window of frame data {ascii: [], colors: []}
let frameQueue = []; // full list of frame data for lazy conversion
let playingInterval = null;
let playing = false;
let paused = false;
let frameIndex = 0;
const WINDOW_SIZE = 100; // number of frames in memory

function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }
function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }

function canvasToAsciiData(ctx, width, height){
  const data = ctx.getImageData(0,0,width,height).data;
  const ascii = [], colors = [];
  for(let y=0;y<height;y++){
    ascii[y] = [];
    colors[y] = [];
    for(let x=0;x<width;x++){
      const i=(y*width+x)*4;
      const r=data[i],g=data[i+1],b=data[i+2];
      const brightness = 0.299*r+0.587*g+0.114*b;
      const idx = Math.floor((brightness/255)*(asciiChars.length-1));
      ascii[y][x]=idx;
      colors[y][x]=[r,g,b];
    }
  }
  return {ascii, colors};
}

function renderFrame(index){
  if(index<0 || index>=frames.length) return;
  const frame = frames[index];
  let html='';
  for(let y=0;y<frame.ascii.length;y++){
    for(let x=0;x<frame.ascii[y].length;x++){
      const ch=asciiChars[frame.ascii[y][x]];
      if(frame.colors) html+=`<span style="color:rgb(${frame.colors[y][x].join(',')})">${ch}</span>`;
      else html+=ch;
    }
    html+='<br>';
  }
  asciiOutput.innerHTML=html;
}

function startPlayback(){
  if(playingInterval) clearInterval(playingInterval);
  const intervalMs = clamp(parseInt(speedInput.value)||100,10,2000);
  playing=true;
  paused=false;
  pauseBtn.disabled=false;
  resumeBtn.disabled=false;
  frameIndex=0;
  if(frames.length===0){ asciiOutput.textContent='No frames.'; return; }
  renderFrame(frameIndex);
  frameIndex=(frameIndex+1)%frames.length;
  playingInterval=setInterval(()=>{
    if(!paused && frames.length){
      renderFrame(frameIndex);
      frameIndex=(frameIndex+1)%frames.length;
      // refill window if needed
      if(frameQueue.length && frames.length<WINDOW_SIZE){
        frames.push(frameQueue.shift());
      }
    }
  }, intervalMs);
  infoEl.textContent=`Playing ${frameQueue.length+frames.length} frames (sliding window).`;
}

function stopPlayback(){
  if(playingInterval){ clearInterval(playingInterval); playingInterval=null; }
  playing=false;
  pauseBtn.disabled=true;
  resumeBtn.disabled=true;
}

function setProgress(current,total,text){
  if(total>0){
    progressEl.max=total;
    progressEl.value=current;
    progressText.textContent=`${text||''} ${current}/${total} (${Math.round(current/total*100)}%)`;
  }else{
    progressEl.removeAttribute('max');
    progressEl.value=current;
    progressText.textContent=`${text||''} ${current} frames`;
  }
}

/* --- Main conversion flows --- */
async function convertStaticImage(file){
  const url=URL.createObjectURL(file);
  const img=new Image();
  img.crossOrigin='anonymous';
  img.src=url;
  await new Promise(res=>img.onload=res);
  const widthChars=clamp(parseInt(sizeInput.value)||120,10,800);
  const scale=img.height/img.width||1;
  const heightChars=Math.max(2,Math.floor(widthChars*scale));
  const canvas=document.createElement('canvas');
  canvas.width=widthChars;
  canvas.height=heightChars;
  const ctx=canvas.getContext('2d');
  ctx.drawImage(img,0,0,widthChars,heightChars);
  const frameData=canvasToAsciiData(ctx,widthChars,heightChars);
  frames=[frameData];
  frameQueue=[];
  setProgress(1,1,'Converted image:');
  startPlayback();
  URL.revokeObjectURL(url);
}

async function convertVideo(file){
  const url=URL.createObjectURL(file);
  const video=document.createElement('video');
  video.muted=true; video.playsInline=true; video.crossOrigin='anonymous'; video.preload='auto'; video.src=url;
  await new Promise(res=>video.onloadedmetadata=res);
  const widthChars=clamp(parseInt(sizeInput.value)||120,10,800);
  const scale=(video.videoHeight||360)/(video.videoWidth||640);
  const heightChars=Math.max(2,Math.floor(widthChars*scale));
  const canvas=document.createElement('canvas');
  canvas.width=widthChars; canvas.height=heightChars;
  const ctx=canvas.getContext('2d');
  const captureFps=clamp(parseInt(captureFpsInput.value)||15,1,60);
  const duration=video.duration||0;
  const maxFrames=clamp(parseInt(maxFramesInput.value)||2000,10,5000);
  const estimatedFrames=Math.min(Math.ceil(duration*captureFps),maxFrames);
  frameQueue=[];
  setProgress(0,estimatedFrames,'Converting video frames:');
  const frameTimes=[];
  for(let i=0;i<estimatedFrames;i++) frameTimes.push(Math.min(i/captureFps,duration));
  for(let t of frameTimes){
    await new Promise(res=>{
      const onseek=()=>{
        try{ctx.drawImage(video,0,0,canvas.width,canvas.height);}catch(e){}
        frameQueue.push(canvasToAsciiData(ctx,canvas.width,canvas.height));
        setProgress(frameQueue.length+frames.length,estimatedFrames,'Converting video frames:');
        res();
      };
      video.currentTime=Math.min(t,video.duration);
      video.addEventListener('seeked',onseek,{once:true});
      setTimeout(res,2000);
    });
    await new Promise(r=>requestIdleCallback(r)); // let browser breathe
  }
  frames=frameQueue.splice(0,WINDOW_SIZE);
  URL.revokeObjectURL(url);
  startPlayback();
}

async function convertGIF(file){
  const url=URL.createObjectURL(file);
  const img=new Image();
  img.crossOrigin='anonymous';
  img.src=url;
  await new Promise(res=>img.onload=res);
  const widthChars=clamp(parseInt(sizeInput.value)||120,10,800);
  const scale=img.height/img.width||1;
  const heightChars=Math.max(2,Math.floor(widthChars*scale));
  const canvas=document.createElement('canvas');
  canvas.width=widthChars; canvas.height=heightChars;
  const ctx=canvas.getContext('2d');
  const maxFrames=clamp(parseInt(maxFramesInput.value)||2000,10,5000);
  frameQueue=[];
  setProgress(0,maxFrames,'Sampling GIF frames:');
  let seen=new Map(), firstHash=null, captureCount=0;
  function imageDataHash(sampleData){
    let h=2166136261>>>0;
    const step=4*Math.max(1,Math.floor(sampleData.length/(4*2000)));
    for(let i=0;i<sampleData.length;i+=step){
      let v=((sampleData[i]<<16)|(sampleData[i+1]<<8)|sampleData[i+2])>>>0;
      h^=v; h=Math.imul(h,16777619)>>>0;
    }
    return ('00000000'+h.toString(16)).slice(-8);
  }
  await new Promise(resolve=>{
    let stop=false;
    function capture(){
      if(stop) return resolve();
      try{ctx.drawImage(img,0,0,canvas.width,canvas.height);}catch(e){}
      const data=ctx.getImageData(0,0,canvas.width,canvas.height).data;
      const h=imageDataHash(data);
      if(firstHash===null) firstHash=h;
      if(h===firstHash && captureCount>0 && seen.has(h) && seen.get(h)!==captureCount-1){ stop=true; return resolve(); }
      frameQueue.push(canvasToAsciiData(ctx,canvas.width,canvas.height));
      seen.set(h,captureCount);
      captureCount++;
      setProgress(captureCount,maxFrames,'Sampling GIF frames:');
      if(captureCount>=maxFrames){ stop=true; return resolve(); }
      requestAnimationFrame(capture);
    }
    requestAnimationFrame(capture);
  });
  frames=frameQueue.splice(0,WINDOW_SIZE);
  URL.revokeObjectURL(url);
  startPlayback();
}

/* --- Top-level convert switch --- */
convertBtn.addEventListener('click', async ev=>{
  ev.preventDefault();
  if(!mediaInput.files[0]) { alert('Please select a file.'); return; }
  convertBtn.disabled=true; pauseBtn.disabled=true; resumeBtn.disabled=true;
  stopPlayback();
  frames=[]; frameQueue=[];
  asciiOutput.textContent=''; progressText.textContent='Starting...';
  infoEl.textContent='Converting...';
  try{
    const file=mediaInput.files[0];
    if(file.type.startsWith('video/')) await convertVideo(file);
    else if(file.type==='image/gif'||file.name.toLowerCase().endsWith('.gif')) await convertGIF(file);
    else if(file.type&&file.type.startsWith('image/')) await convertStaticImage(file);
    else await convertStaticImage(file);
  }catch(err){ console.error(err); progressText.textContent='Error: '+(err.message||String(err)); infoEl.textContent='Conversion failed.'; }
  finally{ convertBtn.disabled=false; }
});

pauseBtn.addEventListener('click', ()=>{ paused=true; infoEl.textContent='Paused.'; });
resumeBtn.addEventListener('click', ()=>{ paused=false; infoEl.textContent='Playing.'; });
speedInput.addEventListener('change', ()=>{ if(playing) startPlayback(); });
sizeInput.addEventListener('change', ()=>{ infoEl.textContent='Size changed — please convert again.'; });
window.addEventListener('beforeunload',()=>stopPlayback());
</script>
</body>
</html>
