<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Image / GIF / Video → Live ASCII (pre-convert frames)</title>
<style>
  :root { --bg:#0b0b0b; --fg:#eaeaea; --muted:#888; --accent:#4aa3ff; }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:monospace}
  .wrap{padding:18px;max-width:1200px;margin:0 auto}
  label,input,button{margin:6px}
  #asciiOutput{white-space:pre; display:inline-block; text-align:left; line-height:7px; font-size:8px; vertical-align:top}
  .controls{margin:12px 0}
  progress{width:380px;height:14px;vertical-align:middle}
  #status{color:var(--muted);margin-left:8px}
  .small{font-size:12px;color:var(--muted)}
  button[disabled]{opacity:0.5}
  .rightcol{display:inline-block; vertical-align:top; margin-left:20px}
</style>
</head>
<body>
  <div class="wrap">
    <h2>Image / GIF / Video → ASCII (pre-convert frames)</h2>

    <div class="controls">
      <input id="mediaInput" type="file" accept="image/*,video/*" />
      <label>Width (chars)</label>
      <input id="size" type="number" value="120" min="10" max="800" />
      <label><input id="color" type="checkbox" /> Color</label>
      <button id="convertBtn" type="button">Convert</button>

      <div style="margin-top:8px">
        <label>Capture FPS (video) </label>
        <input id="captureFps" type="number" value="15" min="1" max="60" style="width:70px" />
        <label style="margin-left:10px">Max Frames</label>
        <input id="maxFrames" type="number" value="400" min="10" max="2000" style="width:80px" />
      </div>

      <div style="margin-top:8px">
        <button id="pauseBtn" type="button" disabled>Pause</button>
        <button id="resumeBtn" type="button" disabled>Resume</button>
        <label style="margin-left:8px">Speed (ms/frame)</label>
        <input id="speed" type="number" value="100" min="10" max="2000" style="width:80px" />
      </div>

      <div style="margin-top:10px">
        <progress id="progress" value="0" max="100"></progress>
        <span id="progressText">Idle</span>
      </div>
    </div>

    <div>
      <pre id="asciiOutput"></pre>
      <div class="rightcol small">
        <div id="info">Ready.</div>
        <div id="notes" style="margin-top:8px;color:var(--muted)">
          Notes: videos use seeking to capture frames (accurate). GIF capture uses a heuristic (captures until it detects the first frame again or max frames).
        </div>
      </div>
    </div>
  </div>

<script>
const asciiChars = " .:-=+*#%@";
const mediaInput = document.getElementById('mediaInput');
const convertBtn  = document.getElementById('convertBtn');
const asciiOutput  = document.getElementById('asciiOutput');
const sizeInput = document.getElementById('size');
const colorCheckbox = document.getElementById('color');
const captureFpsInput = document.getElementById('captureFps');
const maxFramesInput = document.getElementById('maxFrames');
const progressEl = document.getElementById('progress');
const progressText = document.getElementById('progressText');
const infoEl = document.getElementById('info');
const pauseBtn = document.getElementById('pauseBtn');
const resumeBtn = document.getElementById('resumeBtn');
const speedInput = document.getElementById('speed');

let frames = [];
let playingInterval = null;
let playing = false;
let paused = false;
let frameIndex = 0;

function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }
function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

function canvasToAsciiHTML(ctx, width, height){
  const data = ctx.getImageData(0,0,width,height).data;
  let out = '';
  for(let y=0;y<height;y++){
    for(let x=0;x<width;x++){
      const i = (y*width + x)*4;
      const r = data[i], g = data[i+1], b = data[i+2];
      const brightness = (0.299*r + 0.587*g + 0.114*b);
      const idx = Math.floor((brightness/255) * (asciiChars.length-1));
      const ch = asciiChars[idx];
      if(colorCheckbox.checked){
        out += `<span style="color:rgb(${r},${g},${b})">${ch}</span>`;
      } else {
        out += ch;
      }
    }
    out += '<br>';
  }
  return out;
}

function imageDataHash(sampleData){
  let h = 2166136261 >>> 0;
  const step = 4 * Math.max(1, Math.floor(sampleData.length / (4 * 2000)));
  for(let i=0;i<sampleData.length;i+=step){
    let v = ((sampleData[i]<<16) | (sampleData[i+1]<<8) | (sampleData[i+2])) >>> 0;
    h ^= v;
    h = Math.imul(h, 16777619) >>> 0;
  }
  return ('00000000' + h.toString(16)).slice(-8);
}

function setProgress(current, total, text){
  if(total>0){
    progressEl.max = total;
    progressEl.value = current;
    progressText.textContent = `${text || ''} ${current}/${total} (${Math.round((current/total)*100)}%)`;
  } else {
    progressEl.removeAttribute('max');
    progressEl.value = current;
    progressText.textContent = `${text || ''} ${current} frames`;
  }
}

function startPlayback(){
  if(playingInterval) clearInterval(playingInterval);
  const intervalMs = clamp(parseInt(speedInput.value)||100, 10, 2000);
  playing = true;
  paused = false;
  pauseBtn.disabled = false;
  resumeBtn.disabled = false;
  frameIndex = 0;
  if(frames.length === 0){
    asciiOutput.textContent = 'No frames.';
    return;
  }
  asciiOutput.innerHTML = frames[0];
  frameIndex = 1 % frames.length;
  playingInterval = setInterval(()=>{
    if(!paused && frames.length){
      asciiOutput.innerHTML = frames[frameIndex];
      frameIndex = (frameIndex+1) % frames.length;
    }
  }, intervalMs);
  infoEl.textContent = `Playing ${frames.length} frames.`;
}

function stopPlayback(){
  if(playingInterval) { clearInterval(playingInterval); playingInterval = null; }
  playing = false;
  pauseBtn.disabled = true;
  resumeBtn.disabled = true;
}

async function convertStaticImage(file){
  const url = URL.createObjectURL(file);
  const img = new Image();
  img.crossOrigin = 'anonymous';
  img.src = url;
  await new Promise((res,rej)=>{ img.onload = res; img.onerror = () => rej(new Error('Image load failed')); });
  const widthChars = clamp(parseInt(sizeInput.value)||120, 10, 800);
  const scale = img.height/img.width || 1;
  const heightChars = Math.max(2, Math.floor(widthChars * scale));
  const canvas = document.createElement('canvas');
  canvas.width = widthChars;
  canvas.height = heightChars;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(img,0,0,canvas.width,canvas.height);
  const ascii = canvasToAsciiHTML(ctx, canvas.width, canvas.height);
  frames = [ascii];
  setProgress(1,1,'Converted image:');
  startPlayback();
  URL.revokeObjectURL(url);
}

async function convertVideo(file){
  const url = URL.createObjectURL(file);
  const video = document.createElement('video');
  video.muted = true;
  video.playsInline = true;
  video.crossOrigin = 'anonymous';
  video.preload = 'auto';
  video.src = url;
  await new Promise(res=>video.onloadedmetadata=res);

  const widthChars = clamp(parseInt(sizeInput.value)||120, 10, 800);
  const scale = (video.videoHeight || 360) / (video.videoWidth || 640);
  const heightChars = Math.max(2, Math.floor(widthChars * scale));
  const canvas = document.createElement('canvas');
  canvas.width = widthChars;
  canvas.height = heightChars;
  const ctx = canvas.getContext('2d');

  const captureFps = clamp(parseInt(captureFpsInput.value)||15, 1, 60);
  const duration = video.duration || 0;
  const maxFrames = clamp(parseInt(maxFramesInput.value)||400, 10, 5000);
  const estimatedFrames = Math.min(Math.ceil(duration * captureFps), maxFrames);

  frames = [];
  setProgress(0, estimatedFrames, 'Capturing video frames:');

  const frameTimes = [];
  for(let i=0;i<estimatedFrames;i++) frameTimes.push(Math.min(i/captureFps, duration));

  const batchSize = 5;
  for(let i=0;i<frameTimes.length;i+=batchSize){
    const batch = frameTimes.slice(i, i+batchSize);
    await Promise.all(batch.map(t=>new Promise(res=>{
      const onseek = () => { try{ ctx.drawImage(video,0,0,canvas.width,canvas.height); }catch(e){} frames.push(canvasToAsciiHTML(ctx, canvas.width, canvas.height)); setProgress(frames.length, estimatedFrames, 'Capturing video frames:'); res(); };
      video.currentTime = Math.min(t, video.duration);
      video.addEventListener('seeked', onseek, {once:true});
      setTimeout(res, 2000);
    })));
    await sleep(0);
    if(frames.length >= maxFrames) break;
  }

  URL.revokeObjectURL(url);
  setProgress(frames.length, frames.length, 'Capture complete.');
  startPlayback();
}

async function convertGIF(file){
  const url = URL.createObjectURL(file);
  const img = new Image();
  img.crossOrigin = 'anonymous';
  img.src = url;
  await new Promise((res,rej)=>{ img.onload=res; img.onerror=()=>rej(new Error('GIF load failed')); });

  const widthChars = clamp(parseInt(sizeInput.value)||120, 10, 800);
  const scale = img.height/img.width || 1;
  const heightChars = Math.max(2, Math.floor(widthChars * scale));
  const canvas = document.createElement('canvas');
  canvas.width = widthChars;
  canvas.height = heightChars;
  const ctx = canvas.getContext('2d');

  const maxFrames = clamp(parseInt(maxFramesInput.value)||400, 10, 2000);
  frames = [];
  setProgress(0, maxFrames, 'Sampling GIF frames:');

  let seen = new Map();
  let firstHash = null;
  let captureCount = 0;

  const batchSize = 3; // process a few frames per animation frame
  await new Promise(resolve=>{
    let stop = false;
    function capture(){
      if(stop) return resolve();
      for(let b=0;b<batchSize;b++){
        try{ ctx.drawImage(img,0,0,canvas.width,canvas.height); }catch(e){}
        const data = ctx.getImageData(0,0,canvas.width,canvas.height).data;
        const h = imageDataHash(data);
        if(firstHash===null) firstHash=h;
        if(h===firstHash && captureCount>0 && seen.has(h) && seen.get(h)!==captureCount-1){ stop=true; setProgress(captureCount,maxFrames,'GIF capture: loop detected.'); return resolve(); }
        frames.push(canvasToAsciiHTML(ctx, canvas.width, canvas.height));
        seen.set(h,captureCount);
        captureCount++;
        setProgress(captureCount,maxFrames,'Sampling GIF frames:');
        if(captureCount>=maxFrames){ stop=true; return resolve(); }
      }
      requestAnimationFrame(capture);
    }
    requestAnimationFrame(capture);
  });

  URL.revokeObjectURL(url);
  setProgress(frames.length, frames.length, 'GIF sampling complete.');
  startPlayback();
}

convertBtn.addEventListener('click', async ev=>{
  ev.preventDefault();
  if(!mediaInput.files[0]) { alert('Please select a file (image, GIF, or video).'); return; }

  convertBtn.disabled = true;
  pauseBtn.disabled = true;
  resumeBtn.disabled = true;
  stopPlayback();
  frames = [];
  asciiOutput.textContent = '';
  progressText.textContent = 'Starting...';
  infoEl.textContent = 'Converting...';

  try{
    const file = mediaInput.files[0];
    if(file.type.startsWith('video/')) await convertVideo(file);
    else if(file.type==='image/gif' || file.name.toLowerCase().endsWith('.gif')) await convertGIF(file);
    else await convertStaticImage(file);
  }catch(err){
    console.error(err);
    progressText.textContent = 'Error: '+(err?.message||String(err));
    infoEl.textContent = 'Conversion failed.';
  }finally{
    convertBtn.disabled=false;
  }
});

pauseBtn.addEventListener('click',()=>{ paused=true; infoEl.textContent='Paused.'; });
resumeBtn.addEventListener('click',()=>{ paused=false; infoEl.textContent='Playing.'; });
speedInput.addEventListener('change',()=>{ if(playing) startPlayback(); });
sizeInput.addEventListener('change',()=>{ infoEl.textContent='Size changed — please convert again.'; });
window.addEventListener('beforeunload',()=>stopPlayback());
</script>
</body>
</html>
