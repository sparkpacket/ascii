<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Image / GIF / Video → Live ASCII (pre-convert frames)</title>
<style>
  :root { --bg:#0b0b0b; --fg:#eaeaea; --muted:#888; --accent:#4aa3ff; }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:monospace}
  .wrap{padding:18px;max-width:1200px;margin:0 auto}
  label,input,button{margin:6px}
  #asciiOutput{white-space:pre; display:inline-block; text-align:left; line-height:7px; font-size:8px; vertical-align:top}
  .controls{margin:12px 0}
  progress{width:380px;height:14px;vertical-align:middle}
  #status{color:var(--muted);margin-left:8px}
  .small{font-size:12px;color:var(--muted)}
  button[disabled]{opacity:0.5}
  .rightcol{display:inline-block; vertical-align:top; margin-left:20px}
</style>
</head>
<body>
  <div class="wrap">
    <h2>Image / GIF / Video → ASCII (pre-convert frames)</h2>

    <div class="controls">
      <input id="mediaInput" type="file" accept="image/*,video/*" />
      <label>Width (chars)</label>
      <input id="size" type="number" value="120" min="10" max="800" />
      <label><input id="color" type="checkbox" /> Color</label>
      <button id="convertBtn" type="button">Convert</button>

      <div style="margin-top:8px">
        <label>Capture FPS (video) </label>
        <input id="captureFps" type="number" value="15" min="1" max="60" style="width:70px" />
        <label style="margin-left:10px">Max Frames</label>
        <input id="maxFrames" type="number" value="400" min="10" max="2000" style="width:80px" />
      </div>

      <div style="margin-top:8px">
        <button id="pauseBtn" type="button" disabled>Pause</button>
        <button id="resumeBtn" type="button" disabled>Resume</button>
        <label style="margin-left:8px">Speed (ms/frame)</label>
        <input id="speed" type="number" value="100" min="10" max="2000" style="width:80px" />
      </div>

      <div style="margin-top:10px">
        <progress id="progress" value="0" max="100"></progress>
        <span id="progressText">Idle</span>
      </div>
    </div>

    <div>
      <pre id="asciiOutput"></pre>
      <div class="rightcol small">
        <div id="info">Ready.</div>
        <div id="notes" style="margin-top:8px;color:var(--muted)">
          Notes: videos use seeking to capture frames (accurate). GIF capture uses a heuristic (captures until it detects the first frame again or max frames).
        </div>
      </div>
    </div>
  </div>

<script>
/* --- Settings & DOM --- */
const asciiChars = " .:-=+*#%@"; // dark -> light
const mediaInput = document.getElementById('mediaInput');
const convertBtn  = document.getElementById('convertBtn');
const asciiOutput  = document.getElementById('asciiOutput');
const sizeInput = document.getElementById('size');
const colorCheckbox = document.getElementById('color');
const captureFpsInput = document.getElementById('captureFps');
const maxFramesInput = document.getElementById('maxFrames');
const progressEl = document.getElementById('progress');
const progressText = document.getElementById('progressText');
const infoEl = document.getElementById('info');
const pauseBtn = document.getElementById('pauseBtn');
const resumeBtn = document.getElementById('resumeBtn');
const speedInput = document.getElementById('speed');

let frames = [];         // array of precomputed ASCII strings (HTML)
let playingInterval = null;
let playing = false;
let paused = false;
let frameIndex = 0;

/* --- Utility helpers --- */
function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }
function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

/* convert a canvas context into an ASCII HTML string */
function canvasToAsciiHTML(ctx, width, height){
  const data = ctx.getImageData(0,0,width,height).data;
  let out = '';
  for(let y=0;y<height;y++){
    for(let x=0;x<width;x++){
      const i = (y*width + x)*4;
      const r = data[i], g = data[i+1], b = data[i+2];
      const brightness = (0.299*r + 0.587*g + 0.114*b);
      const idx = Math.floor((brightness/255) * (asciiChars.length-1));
      const ch = asciiChars[idx];
      if(colorCheckbox.checked){
        out += `<span style="color:rgb(${r},${g},${b})">${ch}</span>`;
      } else {
        out += ch;
      }
    }
    out += '<br>';
  }
  return out;
}

/* quick 32-bit FNV-1a-ish hash over RGB samples (used for GIF frame repeat detection) */
function imageDataHash(sampleData){
  // sampleData is Uint8ClampedArray
  let h = 2166136261 >>> 0;
  const step = 4 * Math.max(1, Math.floor(sampleData.length / (4 * 2000))); // sample up to ~2000 pixels
  for(let i=0;i<sampleData.length;i+=step){
    // combine r,g,b
    let v = ((sampleData[i]<<16) | (sampleData[i+1]<<8) | (sampleData[i+2])) >>> 0;
    h ^= v;
    h = Math.imul(h, 16777619) >>> 0;
  }
  return ('00000000' + h.toString(16)).slice(-8);
}

/* update progress UI */
function setProgress(current, total, text){
  if(total>0){
    progressEl.max = total;
    progressEl.value = current;
    progressText.textContent = `${text || ''} ${current}/${total} (${Math.round((current/total)*100)}%)`;
  } else {
    progressEl.removeAttribute('max');
    progressEl.value = current;
    progressText.textContent = `${text || ''} ${current} frames`;
  }
}

/* --- Playback controls --- */
function startPlayback(){
  if(playingInterval) clearInterval(playingInterval);
  const intervalMs = clamp(parseInt(speedInput.value)||100, 10, 2000);
  playing = true;
  paused = false;
  pauseBtn.disabled = false;
  resumeBtn.disabled = false;
  frameIndex = 0;
  if(frames.length === 0){
    asciiOutput.textContent = 'No frames.';
    return;
  }
  // fast immediate first frame
  asciiOutput.innerHTML = frames[0];
  frameIndex = 1 % frames.length;
  playingInterval = setInterval(()=>{
    if(!paused && frames.length){
      asciiOutput.innerHTML = frames[frameIndex];
      frameIndex = (frameIndex+1) % frames.length;
    }
  }, intervalMs);
  infoEl.textContent = `Playing ${frames.length} frames.`;
}

function stopPlayback(){
  if(playingInterval) { clearInterval(playingInterval); playingInterval = null; }
  playing = false;
  pauseBtn.disabled = true;
  resumeBtn.disabled = true;
}

/* --- Main conversion flows --- */

/* Convert static image (or GIF first frame fallback) */
async function convertStaticImage(file){
  const url = URL.createObjectURL(file);
  const img = new Image();
  img.crossOrigin = 'anonymous';
  img.src = url;
  await new Promise((res,rej)=>{
    img.onload = res;
    img.onerror = () => rej(new Error('Image load failed'));
  });

  const widthChars = clamp(parseInt(sizeInput.value)||120, 10, 800);
  const scale = img.height/img.width || 1;
  const heightChars = Math.max(2, Math.floor(widthChars * scale));
  const canvas = document.createElement('canvas');
  canvas.width = widthChars;
  canvas.height = heightChars;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(img,0,0,canvas.width,canvas.height);
  const ascii = canvasToAsciiHTML(ctx, canvas.width, canvas.height);
  frames = [ascii];
  setProgress(1,1,'Converted image:');
  startPlayback();
  URL.revokeObjectURL(url);
}

/* Convert video by seeking to each timestamp (configurable fps) */
async function convertVideo(file){
  const url = URL.createObjectURL(file);
  const video = document.createElement('video');
  video.muted = true;
  video.playsInline = true;
  video.crossOrigin = 'anonymous';
  video.preload = 'auto';
  video.src = url;

  await new Promise((res,rej)=>{
    video.onloadedmetadata = () => {
      // some browsers give 0 width/height until loaded sufficiently - guard by small delay
      setTimeout(res, 0);
    };
    video.onerror = () => rej(new Error('Video failed to load metadata'));
  });

  const widthChars = clamp(parseInt(sizeInput.value)||120, 10, 800);
  const scale = (video.videoHeight || 360) / (video.videoWidth || 640);
  const heightChars = Math.max(2, Math.floor(widthChars * scale));
  const canvas = document.createElement('canvas');
  canvas.width = widthChars;
  canvas.height = heightChars;
  const ctx = canvas.getContext('2d');

  const captureFps = clamp(parseInt(captureFpsInput.value)||15, 1, 60);
  const duration = video.duration || 0;
  const maxFrames = clamp(parseInt(maxFramesInput.value)||400, 10, 5000);
  const estimatedFrames = Math.min(Math.ceil(duration * captureFps), maxFrames);

  frames = [];
  setProgress(0, estimatedFrames, 'Capturing video frames:');

  // We'll step by time and use the 'seeked' event to draw the accurate frame
  const frameTimes = [];
  for(let i=0;i<estimatedFrames;i++){
    frameTimes.push(Math.min(i/captureFps, duration));
  }

  for(let i=0;i<frameTimes.length;i++){
    const t = frameTimes[i];
    // seek
    await new Promise((res,rej) => {
      const onseek = () => {
        // draw frame
        try{
          ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        }catch(e){
          // some codecs might throw - fallback to clear and continue
          ctx.clearRect(0,0,canvas.width,canvas.height);
        }
        // convert
        const ascii = canvasToAsciiHTML(ctx, canvas.width, canvas.height);
        frames.push(ascii);
        setProgress(i+1, frameTimes.length, 'Capturing video frames:');
        // small yield so UI can update
        setTimeout(res, 0);
      };
      video.currentTime = Math.min(t, video.duration || t);
      // some browsers fire 'seeked' immediately else after decode
      video.addEventListener('seeked', onseek, {once:true});
      // safety timeout in case 'seeked' never fires (rare)
      setTimeout(()=> {
        // draw anyway
        try{ ctx.drawImage(video,0,0,canvas.width,canvas.height);}catch(e){}
        frames.push(canvasToAsciiHTML(ctx, canvas.width, canvas.height));
        setProgress(i+1, frameTimes.length, 'Capturing video frames: (timeout)');
        res();
      }, 2000);
    });
    // yield between frames a little to keep UI fluid for long conversions
    await sleep(0);
    // if user-specified maxFrames is hit, break
    if(frames.length >= maxFrames) break;
  }

  URL.revokeObjectURL(url);
  setProgress(frames.length, frames.length, 'Capture complete.');
  startPlayback();
}

/* Convert GIF by sampling the animated <img> repeatedly and detecting loop via hashing */
async function convertGIF(file){
  const url = URL.createObjectURL(file);
  const img = new Image();
  img.crossOrigin = 'anonymous';
  img.src = url;

  await new Promise((res,rej)=>{
    img.onload = res;
    img.onerror = () => rej(new Error('GIF load failed'));
  });

  const widthChars = clamp(parseInt(sizeInput.value)||120, 10, 800);
  const scale = img.height/img.width || 1;
  const heightChars = Math.max(2, Math.floor(widthChars * scale));
  const canvas = document.createElement('canvas');
  canvas.width = widthChars;
  canvas.height = heightChars;
  const ctx = canvas.getContext('2d');

  const maxFrames = clamp(parseInt(maxFramesInput.value)||400, 10, 2000);
  frames = [];
  setProgress(0, maxFrames, 'Sampling GIF frames:');

  let seen = new Map();
  let firstHash = null;
  let captureCount = 0;

  // We'll poll via requestAnimationFrame while the GIF animates in the Image element.
  await new Promise((resolve)=>{
    let stop = false;
    function capture(){
      if(stop) return resolve();
      try{
        ctx.drawImage(img,0,0,canvas.width,canvas.height);
      }catch(e){ /* ignore */ }
      const data = ctx.getImageData(0,0,canvas.width,canvas.height).data;
      const h = imageDataHash(data);

      // If it's the first frame, store its hash
      if(firstHash === null) firstHash = h;

      // If we've seen this hash before and it's the same as the first frame,
      // and we've captured at least 2 frames, assume the GIF looped.
      if(h === firstHash && captureCount > 0){
        // to avoid stopping immediately on first repetition of two-frame gifs,
        // ensure at least 2 cycles or haven't just captured the same frame twice in a row.
        if(seen.has(h) && seen.get(h) !== captureCount - 1){
          stop = true;
          setProgress(captureCount, maxFrames, 'GIF capture: loop detected.');
          return resolve();
        }
      }

      // If not a duplicate of the very last captured frame, push it
      const lastHash = frames.length ? frames[frames.length-1].slice(0,8) : null;
      // convert now and store full HTML string
      const ascii = canvasToAsciiHTML(ctx, canvas.width, canvas.height);
      // store a tiny prefix of ascii to compare quickly? we store hash separately:
      frames.push(ascii);
      seen.set(h, captureCount);
      captureCount++;
      setProgress(captureCount, maxFrames, 'Sampling GIF frames:');

      if(captureCount >= maxFrames){
        stop = true;
        return resolve();
      }
      // schedule next capture on the next frame
      requestAnimationFrame(capture);
    }
    requestAnimationFrame(capture);
  });

  URL.revokeObjectURL(url);
  setProgress(frames.length, frames.length, 'GIF sampling complete.');
  startPlayback();
}

/* --- Top-level convert switch --- */
convertBtn.addEventListener('click', async (ev) => {
  ev.preventDefault();
  if(!mediaInput.files[0]) { alert('Please select a file (image, GIF, or video).'); return; }

  // disable UI while converting
  convertBtn.disabled = true;
  pauseBtn.disabled = true;
  resumeBtn.disabled = true;
  stopPlayback();
  frames = [];
  asciiOutput.textContent = '';
  progressText.textContent = 'Starting...';
  infoEl.textContent = 'Converting...';
  try{
    const file = mediaInput.files[0];
    // handle types:
    if(file.type.startsWith('video/')){
      await convertVideo(file);
    } else if(file.type === 'image/gif' || file.name.toLowerCase().endsWith('.gif')){
      await convertGIF(file);
    } else if(file.type && file.type.startsWith('image/')){
      await convertStaticImage(file);
    } else {
      // fallback: try image route first
      await convertStaticImage(file);
    }
  }catch(err){
    console.error(err);
    progressText.textContent = 'Error: ' + (err && err.message ? err.message : String(err));
    infoEl.textContent = 'Conversion failed.';
  } finally {
    convertBtn.disabled = false;
  }
});

/* Pause/Resume hooks (during playback) */
pauseBtn.addEventListener('click', () => {
  paused = true;
  infoEl.textContent = 'Paused.';
});

resumeBtn.addEventListener('click', () => {
  paused = false;
  infoEl.textContent = 'Playing.';
});

/* Changing the speed should restart the playback with the new interval */
speedInput.addEventListener('change', () => {
  if(playing) startPlayback();
});

/* Keep UI tidy if user changes options while playing */
sizeInput.addEventListener('change', () => {
  // user should convert again to reflect size change
  infoEl.textContent = 'Size changed — please convert again.';
});

/* Safety: if the user navigates away, stop intervals */
window.addEventListener('beforeunload', () => stopPlayback());

</script>
</body>
</html>
