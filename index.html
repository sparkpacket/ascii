<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ASCII Converter – Persistent Mobile Friendly</title>
<style>
  :root { --bg:#0b0b0b; --fg:#eaeaea; --muted:#888; --accent:#4aa3ff; }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:monospace}
  .wrap{padding:18px;max-width:1200px;margin:0 auto}
  label,input,button{margin:6px}
  #asciiOutput{white-space:pre; display:inline-block; text-align:left; line-height:7px; font-size:8px; vertical-align:top; max-height:80vh; overflow:auto;}
  .controls{margin:12px 0}
  progress{width:380px;height:14px;vertical-align:middle}
  .small{font-size:12px;color:var(--muted)}
  button[disabled]{opacity:0.5}
  .rightcol{display:inline-block; vertical-align:top; margin-left:20px}
</style>
</head>
<body>
<div class="wrap">
  <h2>Image / GIF / Video → ASCII (Persistent & Mobile-Friendly)</h2>

  <div class="controls">
    <input id="mediaInput" type="file" accept="image/*,video/*" />
    <label>Width (chars)</label>
    <input id="size" type="number" value="120" min="10" max="300" />
    <label><input id="color" type="checkbox" /> Color</label>
    <button id="convertBtn" type="button">Convert</button>

    <div style="margin-top:8px">
      <label>Capture FPS (video) </label>
      <input id="captureFps" type="number" value="15" min="1" max="30" style="width:70px" />
      <label style="margin-left:10px">Max Frames</label>
      <input id="maxFrames" type="number" value="500" min="10" max="2000" style="width:80px" />
    </div>

    <div style="margin-top:8px">
      <button id="pauseBtn" type="button" disabled>Pause</button>
      <button id="resumeBtn" type="button" disabled>Resume</button>
      <label style="margin-left:8px">Speed (ms/frame)</label>
      <input id="speed" type="number" value="100" min="10" max="2000" style="width:80px" />
    </div>

    <div style="margin-top:10px">
      <progress id="progress" value="0" max="100"></progress>
      <span id="progressText">Idle</span>
    </div>
  </div>

  <div>
    <pre id="asciiOutput"></pre>
    <div class="rightcol small">
      <div id="info">Ready.</div>
      <div id="notes" style="margin-top:8px;color:var(--muted)">
        Notes: Conversion is persistent and resumes after reloads. Large GIFs/videos are processed in batches to prevent crashes on mobile.
      </div>
    </div>
  </div>
</div>

<script>
const asciiChars = " .:-=+*#%@";
const mediaInput = document.getElementById('mediaInput');
const convertBtn  = document.getElementById('convertBtn');
const asciiOutput  = document.getElementById('asciiOutput');
const sizeInput = document.getElementById('size');
const colorCheckbox = document.getElementById('color');
const captureFpsInput = document.getElementById('captureFps');
const maxFramesInput = document.getElementById('maxFrames');
const progressEl = document.getElementById('progress');
const progressText = document.getElementById('progressText');
const infoEl = document.getElementById('info');
const pauseBtn = document.getElementById('pauseBtn');
const resumeBtn = document.getElementById('resumeBtn');
const speedInput = document.getElementById('speed');

let frames=[], frameQueue=[], playing=false, paused=false, frameIndex=0;
const WINDOW_SIZE=100;
const SAVE_EVERY_N_FRAMES=10;
let fileMeta=null;

const idleCallback = window.requestIdleCallback || function(fn){ return setTimeout(fn, 0); };

function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }

function canvasToAsciiData(ctx,width,height){
  const data = ctx.getImageData(0,0,width,height).data;
  const ascii=[], colors=[];
  for(let y=0;y<height;y++){ ascii[y]=[]; colors[y]=[]; for(let x=0;x<width;x++){
    const i=(y*width+x)*4;
    const r=data[i], g=data[i+1], b=data[i+2];
    const brightness=0.299*r+0.587*g+0.114*b;
    const idx=Math.floor((brightness/255)*(asciiChars.length-1));
    ascii[y][x]=idx; colors[y][x]=[r,g,b];
  }}
  return {ascii, colors};
}

function renderFrame(index){
  if(index<0||index>=frames.length) return;
  const frame=frames[index];
  let html='';
  for(let y=0;y<frame.ascii.length;y++){
    for(let x=0;x<frame.ascii[y].length;x++){
      const ch=asciiChars[frame.ascii[y][x]];
      if(frame.colors) html+=`<span style="color:rgb(${frame.colors[y][x].join(',')})">${ch}</span>`;
      else html+=ch;
    }
    html+='<br>';
  }
  asciiOutput.innerHTML=html;
}

function startPlayback(){
  if(playing) clearInterval(playingInterval);
  const intervalMs = clamp(parseInt(speedInput.value)||100,10,2000);
  playing=true; paused=false; pauseBtn.disabled=false; resumeBtn.disabled=false;
  frameIndex=0;
  if(frames.length===0){ asciiOutput.textContent='No frames.'; return; }
  renderFrame(frameIndex); frameIndex=(frameIndex+1)%frames.length;
  playingInterval=setInterval(()=>{
    if(!paused){
      renderFrame(frameIndex);
      frameIndex=(frameIndex+1)%frames.length;
      if(frameQueue.length && frames.length<WINDOW_SIZE) frames.push(frameQueue.shift());
    }
  }, intervalMs);
  infoEl.textContent=`Playing ${frameQueue.length+frames.length} frames.`;
}

function stopPlayback(){ if(playingInterval){ clearInterval(playingInterval); playingInterval=null; } playing=false; pauseBtn.disabled=true; resumeBtn.disabled=true; }

function setProgress(current,total,text){
  if(total>0){ progressEl.max=total; progressEl.value=current; progressText.textContent=`${text||''} ${current}/${total} (${Math.round(current/total*100)}%)`; }
  else{ progressEl.removeAttribute('max'); progressEl.value=current; progressText.textContent=`${text||''} ${current} frames`; }
}

function saveState(){
  if(!fileMeta) return;
  try{
    const state={fileMeta, frames, frameQueue, frameIndex};
    localStorage.setItem('asciiConvertState',JSON.stringify(state));
  } catch(e){ console.warn('Could not save state:',e); }
}

function loadState(){
  const raw = localStorage.getItem('asciiConvertState');
  if(!raw) return null;
  try{ return JSON.parse(raw); } catch(e){ return null; }
}

// Convert Image (static)
async function convertStaticImage(file){
  fileMeta={name:file.name,size:file.size,lastModified:file.lastModified};
  const url=URL.createObjectURL(file);
  const img=new Image(); img.crossOrigin='anonymous'; img.src=url;
  await new Promise(res=>img.onload=res);
  const widthChars = Math.min(clamp(parseInt(sizeInput.value)||120,10,300),300);
  const scale = img.height/img.width||1; const heightChars=Math.max(2,Math.floor(widthChars*scale));
  const canvas=document.createElement('canvas'); canvas.width=widthChars; canvas.height=heightChars;
  const ctx=canvas.getContext('2d'); ctx.drawImage(img,0,0,widthChars,heightChars);
  frames=[canvasToAsciiData(ctx,widthChars,heightChars)]; frameQueue=[]; frameIndex=0;
  setProgress(1,1,'Converted image:'); startPlayback(); saveState();
  URL.revokeObjectURL(url);
}

// Convert GIF (batch + save)
async function convertGIF(file){
  fileMeta={name:file.name,size:file.size,lastModified:file.lastModified};
  const url=URL.createObjectURL(file);
  const img=new Image(); img.crossOrigin='anonymous'; img.src=url;
  await new Promise(res=>img.onload=res);
  const widthChars = Math.min(clamp(parseInt(sizeInput.value)||120,10,300),300);
  const scale = img.height/img.width||1; const heightChars=Math.max(2,Math.floor(widthChars*scale));
  const canvas=document.createElement('canvas'); canvas.width=widthChars; canvas.height=heightChars;
  const ctx=canvas.getContext('2d');

  const maxFrames = clamp(parseInt(maxFramesInput.value)||500,10,2000);
  frames=[]; frameQueue=[]; let captureCount=0;

  let firstHash=null, seen=new Map();
  async function captureBatch(){
    if(captureCount>=maxFrames) { URL.revokeObjectURL(url); setProgress(frames.length,frames.length,'GIF done.'); startPlayback(); saveState(); return; }
    ctx.clearRect(0,0,widthChars,heightChars); ctx.drawImage(img,0,0,widthChars,heightChars);
    const data=ctx.getImageData(0,0,widthChars,heightChars).data;
    const hash = Array.from(data).slice(0, Math.min(2000*4,data.length)).reduce((h,v)=>((h*31+v)|0),0);
    if(firstHash===null) firstHash=hash;
    if(seen.has(hash) && seen.get(hash)!==captureCount-1 && captureCount>0){ URL.revokeObjectURL(url); setProgress(frames.length,frames.length,'GIF loop detected.'); startPlayback(); saveState(); return; }
    frames.push(canvasToAsciiData(ctx,widthChars,heightChars)); seen.set(hash,captureCount);
    captureCount++;
    if(captureCount % SAVE_EVERY_N_FRAMES===0) saveState();
    setProgress(captureCount,maxFrames,'Sampling GIF frames:');
    setTimeout(captureBatch,0);
  }
  captureBatch();
}

// Convert Video (batch + save)
async function convertVideo(file){
  fileMeta={name:file.name,size:file.size,lastModified:file.lastModified};
  const url=URL.createObjectURL(file);
  const video=document.createElement('video'); video.muted=true; video.playsInline=true; video.crossOrigin='anonymous'; video.preload='auto'; video.src=url;
  await new Promise(res=>video.onloadedmetadata=res);
  const widthChars=Math.min(clamp(parseInt(sizeInput.value)||120,10,300),300);
  const scale=(video.videoHeight||360)/(video.videoWidth||640);
  const heightChars=Math.max(2,Math.floor(widthChars*scale));
  const canvas=document.createElement('canvas'); canvas.width=widthChars; canvas.height=heightChars;
  const ctx=canvas.getContext('2d');

  const captureFps = clamp(parseInt(captureFpsInput.value)||15,1,30);
  const duration = video.duration || 0;
  const maxFrames = clamp(parseInt(maxFramesInput.value)||500,10,2000);
  const estimatedFrames=Math.min(Math.ceil(duration*captureFps),maxFrames);
  frames=[]; frameQueue=[]; let i=0;

  async function processBatch(){
    if(i>=estimatedFrames){ URL.revokeObjectURL(url); setProgress(frames.length,frames.length,'Video done.'); startPlayback(); saveState(); return; }
    const t = Math.min(i/captureFps,duration);
    await new Promise(res=>{
      const onseek=()=>{
        try{ ctx.drawImage(video,0,0,widthChars,heightChars); }catch(e){}
        frames.push(canvasToAsciiData(ctx,widthChars,heightChars));
        if(frames.length % SAVE_EVERY_N_FRAMES===0) saveState();
        setProgress(i+1,estimatedFrames,'Capturing video frames:');
        res();
      };
      video.currentTime=t;
      video.addEventListener('seeked',onseek,{once:true});
      setTimeout(()=>res(),1000);
    });
    i++;
    setTimeout(processBatch,0);
  }
  processBatch();
}

convertBtn.addEventListener('click',async ev=>{
  ev.preventDefault();
  if(!mediaInput.files[0]) { alert('Please select a file.'); return; }
  convertBtn.disabled=true; pauseBtn.disabled=true; resumeBtn.disabled=true;
  stopPlayback(); frames=[]; frameQueue=[]; asciiOutput.textContent=''; progressText.textContent='Starting...'; infoEl.textContent='Converting...';
  try{
    const file=mediaInput.files[0];
    if(file.type.startsWith('video/')) await convertVideo(file);
    else if(file.type==='image/gif' || file.name.toLowerCase().endsWith('.gif')) await convertGIF(file);
    else await convertStaticImage(file);
  } catch(err){ console.error(err); progressText.textContent='Error: '+err.message; infoEl.textContent='Conversion failed.'; }
  finally{ convertBtn.disabled=false; }
});

pauseBtn.addEventListener('click',()=>{ paused=true; infoEl.textContent='Paused.'; });
resumeBtn.addEventListener('click',()=>{ paused=false; infoEl.textContent='Playing.' });
speedInput.addEventListener('change',()=>{ if(playing) startPlayback(); });
sizeInput.addEventListener('change',()=>{ infoEl.textContent='Size changed — please convert again.'; });
window.addEventListener('beforeunload',()=>stopPlayback());

const saved=loadState();
if(saved){ frames=saved.frames||[]; frameQueue=saved.frameQueue||[]; frameIndex=saved.frameIndex||0; fileMeta=saved.fileMeta||null; if(frames.length) { startPlayback(); infoEl.textContent='Resumed from saved state.'; } }
</script>
</body>
</html>
